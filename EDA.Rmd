---
title: Exploratory Data Analysis
---


```{r, echo=FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```


```{r load_libraries}

library(tidyverse)

library(forecast)

library(lubridate)

library(forcats)

library(slider)

library(tidymodels)


```


```{r setup}

theme_set(theme_bw())

plot_eval = TRUE

models_list = list()

```


```{r Import_data}

raw_data = list()

raw_data$spx = read_csv(paste0(
  file.path(Sys.getenv("USERPROFILE"),
            fsep = "\\"),
  "\\OneDrive - Bank Of Israel\\Data\\Asaf\\SPX.csv"))

raw_data$others = read_csv(paste0(
  file.path(Sys.getenv("USERPROFILE"),
            fsep = "\\"),
  "\\OneDrive - Bank Of Israel\\Data\\Asaf\\SPX - OThERS.csv"))

spy = list(spy = raw_data$spx %>%
             rename_all(~tolower(.)) %>%
             mutate(date = mdy(date)) %>%
             mutate_if(~is.character(.), ~as.numeric(.)),
           others = raw_data$others %>%
             rename_all(~tolower(.)) %>%
             mutate(date = mdy(date)) %>%
             mutate_if(~is.character(.), ~as.numeric(.))) %>% 
  reduce(full_join, by = "date")

```



## Summary stats

```{r plot_features_hist}

spy %>% 
  select(-date) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value)) + 
  geom_histogram() + 
  facet_wrap(~name, scales = "free")



```

Many features have outliers (indx_weighted_book_val, dvd_payout_ratio are extreme cases)

```{r plot_features_timeseries_before, eval=plot_eval}

spy %>% 
  pivot_longer(-date) %>% 
  ggplot(aes(x = date, y = value)) + 
  geom_line() + 
  facet_wrap(~name, scales = "free")

```

Most of the timeseries seem to be non stationary

```{r Preprocessing}


# Smoothing outliers
spy = spy %>% 
  mutate(across(c("indx_weighted_book_val",
                  "current_ev_to_book_value"),
                .fns = ~ slide_dbl(.,
                                   median,
                                   .before = 70,
                                   .after = 70)
                ))


# Difference non stationary features

spy = spy %>% 
  mutate(across(-date, ~c(NA, diff(log(.)))))


# Shift spx one day forward

spy = spy %>% 
  mutate(spx_index_lead_1_day = lead(spx_index))



```


```{r plot_features_timeseries_after,eval=plot_eval}

spy %>% 
  pivot_longer(-date) %>% 
  ggplot(aes(x = date, y = value)) + 
  geom_line() + 
  facet_wrap(~name, scales = "free")


```


After log transform and differencing still peaking outliers


```{r Feature_engineering}

# Calculate time periods

spy = spy %>%
  mutate(ret_10 = slide_dbl(spx_index,~diff(log(.x[c(1,10)])),
                            .before = 9,
                              .complete = TRUE)) %>%
  mutate(ret_15 = slide_dbl(spx_index,~diff(log(.x[c(1,15)])),
                            .before = 14,
                             .complete = TRUE)) %>%
  mutate(ret_30 = slide_dbl(spx_index,~diff(log(.x[c(1,30)])),
                            .before = 29,
                              .complete = TRUE))

# Asaf's one feature reg list

 spy = spy %>% 
   mutate(eps_10 = slide_dbl(t12_eps_aggte,~diff(log(.x[c(1,10)])),
                            .before = 9,
                              .complete = TRUE)) %>% 
   mutate(delta_10_year = c(NA,diff(us_gov_yield_10_y))) %>% 
   mutate(delta_3_month = c(NA,diff(us_gov_yield_3_m))) %>% 
   mutate(delta_fed_funds_rate = c(NA,diff(fed_funds_rate))) %>% 
   mutate(delta_HY_spread = c(NA,diff(high_yield_spread))) %>%
   mutate(delta_IG_spread = c(NA,diff(inv_grade_spread)))

```



### Conditional distribution

First we look at return distribution over some period (say 10 day return). In the second step we look at the distribution conditional on one feature (say look at when EPS was positive vs negative)

```{r return_dist}

spy %>% 
  select(ret_10) %>% 
  ggplot(aes(x = ret_10)) + 
  geom_histogram(alpha = 0.5, color = "black") + 
  stat_bin(aes(y = ..count.., label = ..count..),
           geom = "text", vjust = -0.5, color = "magenta",
           size = 3) + 
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 0.1),n.breaks = 10) +
  labs(x = "", title = "Continous return distribution")



```



```{r return_dist_by_eps}

spy %>% 
  select(ret_10, t12_eps_aggte) %>% 
  mutate(eps_dir = c(NA,diff(t12_eps_aggte)) > 0) %>% 
  ggplot(aes(x = ret_10, fill = eps_dir,color = eps_dir)) + 
  geom_density(alpha = 0.3, position = "dodge") + 
  # stat_bin(aes(y = ..count.., label = ..count..),
  #          geom = "text", vjust = -0.5, color = "magenta",
  #          size = 3) + 
  scale_x_continuous(
    labels = scales::percent_format(accuracy = 0.1),n.breaks = 10) +
  labs(x = "",
       title = "Continous return distribution by EPS") + 
  theme(legend.position = "bottom")



```








```{r plot_one_feature_reg}

feature_list = c("eps_10","delta_10_year",
                 "delta_fed_funds_rate","delta_IG_spread")


plot_list = map(feature_list, function(temp_feature){
  
  
  temp_plot = spy %>% 
    select(ret_10, temp_feature) %>% 
    ggplot(aes(x = !!sym(temp_feature), y = ret_10)) + 
    geom_point() + 
    geom_smooth(method = "lm")
  
  
  
  
})


```



## Model fit

```{r fit models, eval=FALSE}

models_list$linear_reg = linear_reg() %>% 
  set_engine("lm")

models_list$logit_reg = logistic_reg() %>% 
  set_engine("glm")


```


```{r train_set_predictions, eval=FALSE}


```


```{r rolling_cross_validation, eval=FALSE}

roll_grid = rolling_origin(spy,initial = 360,assess = 1)

roll_pred = map(roll_grid$splits[sample(1:nrow(roll_grid),10)], function(temp_split){
  
  train_set = analysis(temp_split)
  
  test_set = assessment(temp_split)
  
  linear_pred = models_list$linear_reg %>% 
    fit(spx_index ~ ., data = train_set) %>% 
    predict(new_data = test_set) %>% 
    mutate(return = test_set$spx_index) %>% 
    rename(ret_pred = .pred)
  
  logit_pred = models_list$logit_reg %>% 
    fit(market_dir ~ ., data = train_set) %>% 
    predict(new_data = test_set) %>% 
    mutate(market_dir = test_set$market_dir) %>% 
    rename(market_dir_pred = .pred_class)
  
  return(list(data.frame(date = test_set$date),
              linear_pred, logit_pred) %>% 
           bind_cols())

  
})

roll_pred = roll_pred %>% 
  bind_rows()


rmse = roll_pred %>% 
  select(return, ret_pred) %>% 
  rmse(truth = return, estimate = ret_pred)

accuracy_score = roll_pred %>% 
  select(market_dir, market_dir_pred) %>% 
  accuracy(truth = market_dir, estimate = market_dir_pred)

```

